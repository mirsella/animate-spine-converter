--- /home/mirsella/Downloads/converter.jsfl	2026-01-28 18:34:13.289778110 +0100
+++ output/converter.jsfl	2026-01-28 17:33:02.370273865 +0100
@@ -476,14 +476,14 @@
                     // FORCE BAKING via Keyframe Conversion (Fix for Motion Tweens)
                     // Motion Tweens often report static matrices for the 'base' element.
                     // By converting the specific frame to a keyframe, we force Animate to bake the interpolation.
-                    var undoNeeded = false;
+                    // Note: Since we are running on a temporary file, we do NOT undo this operation.
+                    // This destructively converts the temporary timeline to keyframes, which is fine and faster.
                     // Debug: Capture pre-bake state to verify if baking actually changes values
                     var preBakeTx = el.matrix.tx;
                     var preBakeTy = el.matrix.ty;
                     var preBakeRot = Math.atan2(el.matrix.b, el.matrix.a) * 180 / Math.PI;
                     try {
                         timeline.convertToKeyframes();
-                        undoNeeded = true;
                         // Re-fetch element from the new keyframe
                         var freshLayer = timeline.layers[layerIdx];
                         var freshFrame = freshLayer.frames[i];
@@ -510,42 +510,6 @@
                     catch (e) {
                         Logger_1.Logger.warning("[Converter] Bake failed for frame ".concat(i, " (").concat(layer.name, "): ").concat(e));
                     }
-                    if (undoNeeded) {
-                        // JSFL 'undo' is inconsistent in some contexts (e.g. inside a loop or when editItem is active).
-                        // However, 'document.undo()' is the standard call. The error suggests 'this._document.undo' is not a function.
-                        // This likely means _document is wrapped or typed incorrectly at runtime, OR we are in a context where 'undo' isn't exposed on the wrapper.
-                        // Let's try the global 'fl.getDocumentDOM().undo()' via strict JSFL execution string if available, 
-                        // or cast to any and try accessing the global FLfile/fl object if possible (not standard in TS wrapper).
-                        // Fallback: The wrapper MIGHT expose it as 'undo()' directly if it's a FlashDocument wrapper.
-                        // BUT, looking at the error: "this._document.undo is not a function"
-                        // It implies _document is NOT the native DOM object but a wrapper class that lacks this method.
-                        // We should check if we can access the native object or if there's another way.
-                        // If we can't undo, we MUST NOT bake destructively. 
-                        // TEMPORARY FIX: Assume 'fl.getDocumentDOM().undo()' is what we need, but we can't call 'fl' directly here easily.
-                        // Actually, if this._document is an xJSFL wrapper or similar, we might need to find the right method.
-                        // Let's try to access the global 'fl' object if it exists in the scope (it usually does in JSFL env).
-                        try {
-                            this._document.undo();
-                        }
-                        catch (e) {
-                            // If direct call fails, try the global 'fl' object which is available in JSFL runtime
-                            // We use 'eval' or similar to bypass TS checks for the global 'fl'
-                            // eslint-disable-next-line no-eval
-                            // eval("fl.getDocumentDOM().undo()");
-                            // Or safer:
-                            if (typeof __webpack_require__.g.fl !== 'undefined') {
-                                try {
-                                    __webpack_require__.g.fl.getDocumentDOM().undo();
-                                }
-                                catch (e2) {
-                                    Logger_1.Logger.error("[Converter] Global Undo failed: ".concat(e2));
-                                }
-                            }
-                            else {
-                                Logger_1.Logger.error("[Converter] CRITICAL: Cannot Undo bake! Document structure compromised.");
-                            }
-                        }
-                    }
                     if (!bakedData) {
                         this._document.selectNone();
                         // Selecting the keyframe element while playhead is at 'i' selects the interpolated instance
@@ -566,6 +530,12 @@
                 var sourceMatrix = bakedData ? bakedData.matrix : el.matrix;
                 var sourceTransX = bakedData ? bakedData.transformX : el.transformX;
                 var sourceTransY = bakedData ? bakedData.transformY : el.transformY;
+                // Debug Transform Point
+                var debugItem = el.libraryItem ? el.libraryItem.name : (el.name || '');
+                var isDebugTarget = (debugItem.indexOf('skin_1') >= 0 && (debugItem.indexOf('weapon') >= 0 || debugItem.indexOf('torso') >= 0));
+                if (isDebugTarget) {
+                    Logger_1.Logger.trace("[Transform] ".concat(debugItem, " F=").concat(i, ": Tx=").concat(sourceMatrix.tx.toFixed(1), " Ty=").concat(sourceMatrix.ty.toFixed(1), " Px=").concat(sourceTransX.toFixed(1), " Py=").concat(sourceTransY.toFixed(1), " Baked=").concat(!!bakedData));
+                }
                 if (parentMat) {
                     finalMatrixOverride = this.concatMatrix(sourceMatrix, parentMat);
                     // Transformation Point (Pivot) is in Parent Space (relative to Parent's Origin).
@@ -585,9 +555,6 @@
                     };
                 }
                 // --- DEBUG LOGGING FOR LAYER PARENTING FIX ---
-                var debugItem = el.libraryItem ? el.libraryItem.name : (el.name || '');
-                // Broaden filter for debugging any potential issues, can restrict later
-                var isDebugTarget = (debugItem.indexOf('skin_1') >= 0 || debugItem.indexOf('skin_3') >= 0);
                 if (isDebugTarget) {
                     var logPrefix = "[ParentFix] F=".concat(i, " | Layer: ").concat(layer.name, " | Item: ").concat(debugItem);
                     if (parentMat) {
@@ -663,11 +630,22 @@
             try {
                 context.global.stageType = "structure" /* ConverterStageType.STRUCTURE */;
                 this.convertElement(context);
-                // Logger.trace(`[Converter] Converting animations for symbol instance: ${element.name || element.libraryItem.name}. Found ${context.global.labels.length} labels.`);
-                for (var _i = 0, _a = context.global.labels; _i < _a.length; _i++) {
-                    var l = _a[_i];
-                    // Logger.trace(`  - Processing label: ${l.name} (frames ${l.startFrameIdx}-${l.endFrameIdx})`);
-                    var sub = context.switchContextAnimation(l);
+                Logger_1.Logger.trace("[Converter] Converting animations for symbol instance: ".concat(element.name || element.libraryItem.name, ". Found ").concat(context.global.labels.length, " labels."));
+                // If we found specific labels, process them
+                if (context.global.labels.length > 0 && context.global.labels[0].name !== 'default') {
+                    for (var _i = 0, _a = context.global.labels; _i < _a.length; _i++) {
+                        var l = _a[_i];
+                        Logger_1.Logger.trace("  - Processing label: ".concat(l.name, " (frames ").concat(l.startFrameIdx, "-").concat(l.endFrameIdx, ")"));
+                        var sub = context.switchContextAnimation(l);
+                        sub.global.stageType = "animation" /* ConverterStageType.ANIMATION */;
+                        this.convertElement(sub);
+                    }
+                }
+                else {
+                    // Fallback to default animation processing (full timeline as one animation) if no explicit labels found
+                    // OR if 'default' label was generated by ConvertUtil
+                    Logger_1.Logger.trace("  - Processing default timeline animation (frames 0-".concat(context.global.labels[0].endFrameIdx, ")"));
+                    var sub = context.switchContextAnimation(context.global.labels[0]);
                     sub.global.stageType = "animation" /* ConverterStageType.ANIMATION */;
                     this.convertElement(sub);
                 }
@@ -2563,11 +2541,12 @@
 /*!********************************************************!*\
   !*** ./source/spine/transform/SpineTransformMatrix.ts ***!
   \********************************************************/
-/***/ (function(__unused_webpack_module, exports) {
+/***/ (function(__unused_webpack_module, exports, __webpack_require__) {
 
 
 
 exports.SpineTransformMatrix = void 0;
+var Logger_1 = __webpack_require__(/*! ../../logger/Logger */ "./source/logger/Logger.ts");
 var SpineTransformMatrix = /** @class */ (function () {
     function SpineTransformMatrix(element, reference, matrixOverride, positionOverride) {
         if (reference === void 0) { reference = null; }
@@ -2673,6 +2652,7 @@
         // V2: Removed negation.
         // shearY = -shearY;
         // Unwrap Rotation using Reference (Continuity)
+        var rotRaw = rotation;
         if (reference) {
             var diff = rotation - reference.rotation;
             while (diff > 180) {
@@ -2696,14 +2676,14 @@
         while (shearY > 180)
             shearY -= 360;
         // Debug logging for specific items
-        /*
-        if (debugName.indexOf('skin_1') >= 0 && (debugName.indexOf('weapon') >= 0 || debugName.indexOf('dash') >= 0)) {
-             Logger.trace(`[Decompose-V2] ${debugName}: Det=${det.toFixed(3)} Rot=${rotation.toFixed(1)} Sx=${scaleX.toFixed(2)} Sy=${scaleY.toFixed(2)} ShearY=${shearY.toFixed(1)}`);
-        } else if (debugName.indexOf('dash') >= 0 && Math.abs(scaleX) > 1.5) {
-             // Log abnormally large dash scales
-             Logger.trace(`[Decompose-V2] LARGE DASH: ${debugName}: Det=${det.toFixed(3)} Rot=${rotation.toFixed(1)} Sx=${scaleX.toFixed(2)} Sy=${scaleY.toFixed(2)} ShearY=${shearY.toFixed(1)}`);
+        if (debugName.indexOf('skin_1') >= 0 && (debugName.indexOf('weapon') >= 0 || debugName.indexOf('torso') >= 0)) {
+            Logger_1.Logger.trace("[Decompose] ".concat(debugName, ":"));
+            Logger_1.Logger.trace("  > Input Matrix: a=".concat(mat.a.toFixed(3), " b=").concat(mat.b.toFixed(3), " c=").concat(mat.c.toFixed(3), " d=").concat(mat.d.toFixed(3), " tx=").concat(mat.tx.toFixed(1), " ty=").concat(mat.ty.toFixed(1)));
+            Logger_1.Logger.trace("  > Calc: Det=".concat(det.toFixed(3), " AngleX=").concat(angleX.toFixed(1), " AngleY=").concat(angleY.toFixed(1)));
+            if (reference)
+                Logger_1.Logger.trace("  > Ref: Rot=".concat(reference.rotation.toFixed(1)));
+            Logger_1.Logger.trace("  > Final: Rot=".concat(rotRaw.toFixed(1), "->").concat(rotation.toFixed(1), " Sx=").concat(scaleX.toFixed(2), " Sy=").concat(scaleY.toFixed(2), " ShearY=").concat(shearY.toFixed(1)));
         }
-        */
         return {
             rotation: Math.round(rotation * 10000) / 10000,
             scaleX: Math.round(scaleX * 10000) / 10000,
@@ -4224,19 +4204,6 @@
 /******/ 	}
 /******/ 	
 /************************************************************************/
-/******/ 	/* webpack/runtime/global */
-/******/ 	!function() {
-/******/ 		__webpack_require__.g = (function() {
-/******/ 			if (typeof globalThis === 'object') return globalThis;
-/******/ 			try {
-/******/ 				return this || new Function('return this')();
-/******/ 			} catch (e) {
-/******/ 				if (typeof window === 'object') return window;
-/******/ 			}
-/******/ 		})();
-/******/ 	}();
-/******/ 	
-/************************************************************************/
 var __webpack_exports__ = {};
 // This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
 !function() {
@@ -4251,7 +4218,9 @@
 var Logger_1 = __webpack_require__(/*! ./logger/Logger */ "./source/logger/Logger.ts");
 var SpineFormatV4_2_00_1 = __webpack_require__(/*! ./spine/formats/SpineFormatV4_2_00 */ "./source/spine/formats/SpineFormatV4_2_00.ts");
 var SpineSkeletonHelper_1 = __webpack_require__(/*! ./spine/SpineSkeletonHelper */ "./source/spine/SpineSkeletonHelper.ts");
+var PathUtil_1 = __webpack_require__(/*! ./utils/PathUtil */ "./source/utils/PathUtil.ts");
 //-----------------------------------
+fl.showIdleMessage(false);
 var config = {
     outputFormat: new SpineFormatV4_2_00_1.SpineFormatV4_2_00(),
     imagesExportPath: './images/',
@@ -4269,24 +4238,77 @@
     mergeImages: true
 };
 //-----------------------------------
-var document = fl.getDocumentDOM();
-var converter = new Converter_1.Converter(document, config);
-var result = converter.convertSelection();
-for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
-    var skeleton = result_1[_i];
-    Logger_1.Logger.trace('Exporting skeleton: ' + skeleton.name + '...');
-    if (config.simplifyBonesAndSlots) {
-        SpineSkeletonHelper_1.SpineSkeletonHelper.simplifySkeletonNames(skeleton);
-    }
-    if (skeleton.bones.length > 0) {
-        var skeletonPath = converter.resolveWorkingPath(skeleton.name + '.json');
-        FLfile.write(skeletonPath, skeleton.convert(config.outputFormat));
-        Logger_1.Logger.trace('Skeleton export completed.');
+var run = function () {
+    var originalDoc = fl.getDocumentDOM();
+    if (!originalDoc) {
+        Logger_1.Logger.error("No document open.");
+        return;
+    }
+    if (!originalDoc.pathURI) {
+        Logger_1.Logger.error("Please save the document before exporting.");
+        return;
+    }
+    var originalPath = originalDoc.pathURI;
+    var workingDir = PathUtil_1.PathUtil.parentPath(originalPath);
+    var baseName = PathUtil_1.PathUtil.fileBaseName(originalPath);
+    var tempPath = PathUtil_1.PathUtil.joinPath(workingDir, baseName + "_export_tmp.fla");
+    // Check if we are already in the temp file (prevent infinite recursion if user runs script on temp)
+    if (originalPath.indexOf("_export_tmp.fla") !== -1) {
+        Logger_1.Logger.warning("Running directly on temporary export file.");
+        processDocument(originalDoc);
+        return;
+    }
+    // Clean up any stale temp file
+    if (FLfile.exists(tempPath)) {
+        FLfile.remove(tempPath);
+    }
+    // Copy the current file to temp
+    if (!FLfile.copy(originalPath, tempPath)) {
+        Logger_1.Logger.error("Failed to create temporary export file.");
+        return;
+    }
+    var tempDoc = fl.openDocument(tempPath);
+    if (!tempDoc) {
+        Logger_1.Logger.error("Failed to open temporary export file.");
+        return;
+    }
+    try {
+        processDocument(tempDoc);
+    }
+    catch (e) {
+        Logger_1.Logger.error("An error occurred during conversion: ".concat(e));
+    }
+    finally {
+        // Close temp doc without saving changes
+        tempDoc.close(false);
+        // Remove temp file
+        if (FLfile.exists(tempPath)) {
+            FLfile.remove(tempPath);
+        }
+        // Restore focus to original document
+        fl.openDocument(originalPath);
     }
-    else {
-        Logger_1.Logger.error('Nothing to export.');
+};
+var processDocument = function (document) {
+    var converter = new Converter_1.Converter(document, config);
+    var result = converter.convertSelection();
+    for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
+        var skeleton = result_1[_i];
+        Logger_1.Logger.trace('Exporting skeleton: ' + skeleton.name + '...');
+        if (config.simplifyBonesAndSlots) {
+            SpineSkeletonHelper_1.SpineSkeletonHelper.simplifySkeletonNames(skeleton);
+        }
+        if (skeleton.bones.length > 0) {
+            var skeletonPath = converter.resolveWorkingPath(skeleton.name + '.json');
+            FLfile.write(skeletonPath, skeleton.convert(config.outputFormat));
+            Logger_1.Logger.trace('Skeleton export completed.');
+        }
+        else {
+            Logger_1.Logger.error('Nothing to export.');
+        }
     }
-}
+};
+run();
 //-----------------------------------
 Logger_1.Logger.flush();
 
