Technical Monograph: Advanced Coordinate System Transformation and Matrix Decomposition for Adobe Animate to Spine 4.2 Interoperability1. IntroductionThe evolution of two-dimensional digital animation has bifurcated into two distinct technological lineages: the timeline-based, frame-by-frame paradigm exemplified by Adobe Animate (formerly Flash Professional), and the skeletal, bone-based paradigm championed by runtimes like Spine. Bridging these two environments requires more than simple data translation; it demands a rigorous mathematical translation of coordinate spaces, transformation hierarchies, and pivot logic. The challenge presented—developing a JSFL (JavaScript Flash) export script to migrate assets from Adobe Animate to the Spine 4.2 runtime format—is a classic problem in computer graphics interoperability involving affine transformations and change-of-basis operations.Specifically, the issue of misalignment when utilizing custom registration points indicates a fundamental dissonance between how Adobe Animate calculates visual transformations and how the Spine runtime constructs its scene graph. In Animate, the concept of a "Transformation Point" allows for a mutable pivot that exists independently of the symbol's coordinate origin (Registration Point). Conversely, Spine enforces a strict kinematic chain where a bone’s pivot is synonymous with its local origin.1 This discrepancy leads to deterministic errors: if the Animate Transformation Point is not correctly mapped to the Spine Bone origin, and if the visual assets are not inversely translated to account for this shift, the resulting animation will exhibit "orbiting" artifacts where assets rotate around incorrect centers, or "drifting" artifacts where static positions are calculated with erroneous offsets.This report serves as a comprehensive engineering analysis of these systems. It provides a foundational review of affine geometry as applied to 2D graphics, a detailed comparative analysis of the Animate and Spine coordinate architectures, and a derivation of the linear algebra required to decompose Animate matrices into Spine-compatible transform components (Translation, Rotation, Scale, Shear). Furthermore, it proposes a robust algorithmic strategy to resolve the custom registration point misalignment by mathematically decoupling the visual pivot from the asset origin during the export process.2. Theoretical Framework: Affine Transformations in 2D GraphicsTo address the specific misalignment issues reported in the debugging data, one must first establish the mathematical ground truth governing 2D transformations. Both Adobe Animate and Spine rely on affine transformations to manipulate geometry. An affine transformation preserves collinearity (points on a line remain on a line) and ratios of distances along a line, though it does not necessarily preserve angles or lengths.2.1 Matrix RepresentationIn two-dimensional space, a linear transformation (scaling, rotation, shearing) can be represented by a $2 \times 2$ matrix. However, translation is not a linear transformation but an affine one. To represent translation within the same matrix formalism—allowing for the concatenation of transformations via matrix multiplication—computer graphics systems utilize homogeneous coordinates. A 2D point $(x, y)$ is represented as the vector $[x, y, 1]^T$. This augments the transformation matrix to a $3 \times 3$ structure.2The standard transformation matrix $\mathbf{M}$ is defined as:$$\mathbf{M} = \begin{bmatrix} 
a & c & t_x \\ 
b & d & t_y \\ 
0 & 0 & 1 
\end{bmatrix}$$In the context of JSFL (Adobe Animate’s scripting API) and ActionScript, these components are exposed directly as properties of the Matrix object:$a$: Defines scaling along the x-axis and contributes to rotation (cosine component).$b$: Defines skewing along the y-axis and contributes to rotation (sine component).$c$: Defines skewing along the x-axis and contributes to rotation (negative sine component).$d$: Defines scaling along the y-axis and contributes to rotation (cosine component).$t_x$: Translation along the x-axis.$t_y$: Translation along the y-axis.It is critical to note that while the third row $$ is implicit in most 2D graphics APIs, its mathematical presence ensures that translation is treated as a shear in the 3rd dimension of homogeneous space, allowing it to be composed multiplicatively with rotation and scale.42.2 Order of Operations and ConcatenationA frequent source of errors in export scripts is the non-commutative nature of matrix multiplication. The order in which transformations are applied dictates the final position of the object. In Adobe Animate, the visual result of a "Free Transform" operation is essentially a concatenation of matrices in a specific order: typically Scale, then Skew/Rotate, then Translate.$$\mathbf{M}_{final} = \mathbf{M}_{translate} \times \mathbf{M}_{rotate} \times \mathbf{M}_{scale}$$However, when decomposing this matrix for Spine, we are effectively reversing this process. Spine applies transformations in a specific order: Scale, then Shear, then Rotation, then Translation.5 If the exporter blindly copies values without respecting this operational order, the resulting transform will be mathematically distinct from the source, leading to the visual misalignment observed in the debugging report. The misalignment of assets attached to bones is a direct manifestation of applying a translation before a rotation when the source system applied it after, or vice versa, relative to the pivot point.3. Comparative Analysis: Animate vs. Spine Coordinate SystemsThe misalignment described in the user query stems from fundamental architectural differences between the source and destination platforms. A pixel-perfect export requires a "change of basis" operation to map vectors from the Animate space to the Spine space.3.1 Adobe Animate: The Display List ParadigmAdobe Animate’s architecture is rooted in the Flash Display List. Its coordinate system is "screen-space" oriented.3.1.1 World Space and AxesOrigin: The top-left corner of the stage is $(0,0)$.X-Axis: Positive values extend to the right ($+X$).Y-Axis: Positive values extend downward ($+Y$). This is a standard raster graphics convention but differs from the Cartesian coordinate system used in pure mathematics and many 3D engines.7Rotation: Due to the inverted Y-axis (relative to Cartesian), positive rotation values indicate a Clockwise (CW) rotation.8 This is a critical inversion point; exporting a rotation of $+45^\circ$ from Animate to a system expecting Counter-Clockwise (CCW) rotation will result in a $90^\circ$ error (the difference between $+45^\circ$ and $-45^\circ$).3.1.2 The Registration Point vs. Transformation Point DichotomyThis is the single most significant factor in the reported misalignment. Animate distinguishes between two pivots:Registration Point (Origin): This is the immutable $(0,0)$ point of the Symbol itself. When a symbol is placed on the stage at $x=100, y=100$, it is the Registration Point that sits at that coordinate. This point corresponds to the element.x and element.y properties in JSFL.10Transformation Point (Pivot): This is a mutable point, represented visually as a white circle, around which the user rotates or scales the object. In JSFL, this is accessed via element.getTransformationPoint().Crucially, in Animate, moving the Transformation Point does not change the matrix translation $(t_x, t_y)$. Instead, Animate applies an offset translation to the drawing context, rotates, and then applies the inverse offset. The object rotates around the Transformation Point, but its "position" property remains defined by the Registration Point.3.2 Spine 4.2: The Skeletal ParadigmSpine operates on a hierarchical graph of bones, designed for runtime kinematics.3.2.1 Bone SpaceOrigin: A bone defines its own local coordinate system. The "head" of the bone is always at $(0,0)$ in its local space.1Axes: The X-axis extends along the length of the bone. The Y-axis is perpendicular.Rotation: Spine generally treats positive rotation as Counter-Clockwise (CCW), following standard trigonometric conventions.5 This requires a sign inversion when importing data from Animate.Y-Axis Orientation: In the Spine Editor, the Y-axis points Up (Cartesian). However, the JSON export format is agnostic; it stores the local transform values. When loaded into a runtime (e.g., spine-libgdx or Unity), the coordinate system often defaults to Y-Up, but can be configured for Y-Down. The user's query specifies Spine runtime format 4.2; typically, one must verify if the target engine is Y-Up or Y-Down. Assuming a standard export, the Y-axis values might need negation if the target runtime expects Y-Up while Animate provides Y-Down.133.2.2 Attachment LogicIn Spine, visual assets (Region Attachments) are not bones; they are attached to Slots, which are attached to Bones.The Region Attachment has offset properties: x, y, rotation, scaleX, scaleY.These offsets define where the center of the image is drawn relative to the origin of the bone.153.3 The Core DivergenceThe misalignment occurs because the export script likely maps Animate's element.x/y (Registration Point) directly to Spine's Bone x/y.Scenario: A user in Animate moves the Transformation Point to the shoulder of a character arm, while the Registration Point remains at the center of the bounding box. They rotate the arm.Naive Export: The script places the Spine bone at the Registration Point (center of arm). It applies the rotation.Result: The arm rotates around its center, not the shoulder. The visual asset "orbits" the intended pivot rather than pivoting on it.To fix this, the Spine bone must be placed at the coordinates of the Animate Transformation Point, not the Registration Point. However, doing so introduces a secondary error: the visual asset (the arm graphic) is drawn relative to the Registration Point. If we move the bone to the Transformation Point, we effectively slide the image by the distance between the two points. We must therefore apply a counter-translation to the Region Attachment to push the image back to its correct relative position.4. Mathematical Approach: Matrix Decomposition and Coordinate ConversionResolving the misalignment requires a rigorous application of linear algebra to decompose the affine matrix from Animate and reconstruct it within the constraints of the Spine hierarchy.4.1 Decomposing the Animate MatrixWe begin with the JSFL Matrix $\mathbf{M}$. We must extract the geometric components: Scale ($S_x, S_y$), Rotation ($\theta$), and Shear/Skew ($k_x, k_y$). Note that Animate supports independent skewing of axes, which mathematically results in a non-orthogonal basis. Spine 4.2 supports Shear, which accounts for this non-orthogonality.6The decomposition of a 2D affine matrix is typically performed using a variation of the polar decomposition or QR decomposition. Given $\mathbf{M}$ components $a, b, c, d$:1. Scale Extraction:Scale is the magnitude of the basis vectors.$$S_x = \sqrt{a^2 + b^2}$$$$S_y = \sqrt{c^2 + d^2}$$2. Determinant Check (Flipping):We must check the determinant to see if the element is flipped (e.g., scale X is -1).$$\text{det} = (a \times d) - (b \times c)$$If $\text{det} < 0$, the coordinate system is inverted (handedness change). In Spine, this is usually handled by negating one of the scales (typically $S_y$ in a local decomposition, or $S_x$ depending on convention). If $\text{det} < 0$, we set $S_y = -S_y$.3. Rotation Extraction:Rotation is the angle of the primary basis vector (usually X) relative to the global axes.$$\theta_{rad} = \operatorname{atan2}(b, a)$$$$\theta_{deg} = \theta_{rad} \times \frac{180}{\pi}$$Critical Adjustment: Since Animate is CW and Spine is CCW, the exported rotation must be negated:$$\theta_{spine} = -\theta_{deg}$$4. Shear Extraction:Shear is defined by the angle between the X and Y basis vectors. In an orthogonal system, they are $90^\circ$ apart. Any deviation is shear.$$\phi_{rad} = \operatorname{atan2}(d, c)$$Ideally, $\phi_{rad} = \theta_{rad} + \frac{\pi}{2}$ (for CCW) or $\theta_{rad} - \frac{\pi}{2}$ (for CW).In Spine, shear is often defined as the angle offset of the Y axis relative to the X axis (minus $90^\circ$).$$\text{shear}_{spine} = (\phi_{rad} - \theta_{rad} - \frac{\pi}{2}) \times \frac{180}{\pi}$$Note: The direction of shear calculation depends on the handedness of the system. In a Y-Down system converting to Y-Up, the shear sign may also need inversion.4.2 The "Smart Pivot" Algorithm (Correcting the Misalignment)This section details the specific mathematical operation required to solve the "custom registration point" issue.Definitions:$P_{reg}$: The global position of the Animate Registration Point (derived from element.x, element.y and parent transforms).$P_{trans}$: The global position of the Animate Transformation Point (derived from element.getTransformationPoint() transformed to world space).$\mathbf{M}_{bone}$: The transformation matrix of the bone we are creating (located at $P_{trans}$, rotated/scaled per the decomposition above).The Logic:Bone Position: The Spine bone must be positioned at $P_{trans}$. This ensures the center of rotation matches the user's intent in Animate.$$Bone_{x,y} = P_{trans}$$Asset Offset: The visual asset (Region Attachment) is essentially "anchored" at $P_{reg}$ in the source art. Since we moved the bone to $P_{trans}$, we must calculate the vector from the new bone position to the old anchor point.$$\mathbf{V}_{diff} = P_{reg} - P_{trans}$$This vector $\mathbf{V}_{diff}$ represents the offset in the Parent/World Coordinate Space.Localizing the Offset: Spine Region Attachments are defined in the Bone's Local Coordinate Space. Therefore, we must transform $\mathbf{V}_{diff}$ by the inverse of the Bone's transformation matrix (specifically the Rotation and Scale components; translation is irrelevant here as we are dealing with a relative vector).The Calculation:Let $\theta$ be the bone's rotation (in Spine convention) and $S_x, S_y$ be the scales.To transform world vector $\mathbf{V}_{diff}$ to local vector $\mathbf{V}_{local}$:Inverse Rotation: Rotate $\mathbf{V}_{diff}$ by $-\theta$.$$x' = \mathbf{V}_{diff}.x \cos(-\theta) - \mathbf{V}_{diff}.y \sin(-\theta)$$$$y' = \mathbf{V}_{diff}.x \sin(-\theta) + \mathbf{V}_{diff}.y \cos(-\theta)$$Inverse Scale: Divide by the scale factors.$$x_{local} = \frac{x'}{S_x}$$$$y_{local} = \frac{y'}{S_y}$$These values ($x_{local}, y_{local}$) are exactly what must be written into the x and y properties of the Region Attachment in the Spine JSON. This effectively "pushes" the image back to its original visual location relative to the pivot.Table 1: Coordinate Mapping StrategyFeatureAdobe Animate (Source)Spine 4.2 (Target)Conversion LogicPivottransformationPoint (Visual Pivot)Bone Origin (0,0)Place Bone at Animate transformationPoint.Asset OriginregistrationPoint (Data Origin)Region Attachment (0,0)Calculate vector $Reg - Trans$. Apply Inverse Bone Transform. Set as Attachment x,y.RotationClockwise (+)Counter-Clockwise (+)$\theta_{spine} = -\theta_{animate}$Y-AxisDown (+)Down or Up (Runtime dependent)If target is Y-Up: $y_{spine} = -y_{animate}$ (also affects rotation sign).ScaleGlobal Scale in MatrixLocal Scale ChainExtract scale magnitude from matrix basis vectors.5. Analysis of Debugging ReportBased on the prompt's reference to "misalignment issues with assets attached to bones when they have custom registration points," and typical artifacts generated by naive exporters, we can infer the specific nature of the debugging errors.5.1 Artifact 1: The "Orbiting" AssetObservation: When the bone rotates, the attached asset appears to orbit around the bone rather than pivoting in place (or pivoting at the intended joint).Root Cause: The Bone was placed at the Animate Registration Point ($P_{reg}$), but the visual rotation in Animate was intended around the Transformation Point ($P_{trans}$). The distance $|\mathbf{V}_{diff}|$ acts as a radius arm.Analysis: This confirms that the exporter is reading element.x and element.y as the bone coordinates. In Animate, element.x/y are merely the coordinates of the Registration Point. The visual rotation logic in Animate automatically compensates for the offset pivot mathematically, but the naive export loses this compensation context.5.2 Artifact 2: The "Drifting" PivotObservation: The bone is at the correct visual pivot (e.g., the shoulder), but the arm graphic is floating several pixels away from the bone.Root Cause: The exporter correctly identified the Transformation Point ($P_{trans}$) and placed the bone there. However, it failed to apply the inverse offset to the Region Attachment. It likely set the Attachment's x and y to 0.Analysis: Since the image's internal origin is $P_{reg}$, placing the image at the bone (which is at $P_{trans}$) without an offset effectively shifts the image by vector $-\mathbf{V}_{diff}$. The logic derived in Section 4.2 serves to negate this drift.5.3 Artifact 3: Skew DistortionObservation: When an object is skewed in Animate, the Spine export looks distorted or scaled incorrectly.Root Cause: Animate treats Skew X and Skew Y as independent affine operations. Spine treats them as Rotation + Shear.Analysis: A naive decomposition often conflates rotation and skew. If $b$ and $c$ in the matrix are non-zero, simply taking $\operatorname{atan2}(b, a)$ as rotation is insufficient if shear exists. The difference between the x-axis angle and y-axis angle must be calculated to derive the shear property for the Spine bone.176. Implementation AlgorithmThe following step-by-step algorithm is designed for implementation in JSFL. It addresses the change of basis and matrix decomposition requirements.6.1 Step 1: Element Traversal and Matrix RetrievalIterate through the selected elements in the Animate timeline. For each element:Retrieve the global matrix using element.matrix.Retrieve the transformation point using element.getTransformationPoint(). Note that JSFL documentation and behavior can be inconsistent regarding coordinate spaces. It is imperative to normalize this point to the parent's coordinate space. Typically, getTransformationPoint() returns the point in the coordinate space of the parent.86.2 Step 2: Bone Transform CalculationConstruct the Spine Bone data.Position: Set Bone $X, Y$ to the transformationPoint coordinates.Decomposition: Decompose the matrix $\mathbf{M}$ as described in Section 4.1.Calculate $S_x, S_y$ (Scale).Calculate $\theta$ (Rotation). Negate for Spine.Calculate Shear if necessary.6.3 Step 3: Region Attachment CompensationConstruct the Region Attachment data.Calculate Global Offset:$$dx = element.x - transformationPoint.x$$$$dy = element.y - transformationPoint.y$$(Note: element.x/y are the RegPoint coordinates).Inverse Transform:Convert the global offset $(dx, dy)$ into the bone's local space using the inverse of the bone's rotation and scale.JavaScript// JSFL Pseudo-code
var angleRad = -bone.rotation \* (Math.PI / 180); // Negate for inverse rotation
var cos = Math.cos(angleRad);
var sin = Math.sin(angleRad);

// Rotate
var rotatedX = dx _ cos - dy _ sin;
var rotatedY = dx _ sin + dy _ cos;

// Scale
var attachmentX = rotatedX / bone.scaleX;
var attachmentY = rotatedY / bone.scaleY;
Dimensions: Set the Attachment width/height to the original Library Item dimensions, effectively element.width / element.scaleX. It is safer to inspect the library item directly to get unscaled dimensions to avoid precision loss.6.4 Step 4: Hierarchy ManagementIf the elements are nested (e.g., Forearm inside UpperArm), this logic must be recursive. The "Global" coordinates mentioned above effectively become "Parent-Relative" coordinates. The getTransformationPoint() of a child element returns coordinates relative to the parent symbol. This aligns perfectly with Spine's local bone hierarchy, meaning no additional world-to-local conversion is needed between bones, provided the recursion order is correct (Parent then Child).6.5 Javascript (JSFL) Implementation SnippetThe following code structure implements the mathematical concepts derived above.JavaScript/\*\*

- Decomposes an Animate Matrix into Spine components.
- @param {Object} mat - The JSFL Matrix object {a, b, c, d, tx, ty}
- @returns {Object} - {rotation, scaleX, scaleY, shearX, shearY}
  \*/
  function decomposeMatrix(mat) {
  var sign = Math.atan2(mat.b, mat.a);
      // Extract Scale
      var scaleX = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
      var scaleY = Math.sqrt(mat.c * mat.c + mat.d * mat.d);

      // Determinant check for flip
      var det = mat.a * mat.d - mat.b * mat.c;
      if (det < 0) {
          scaleY = -scaleY;
          sign = Math.atan2(-mat.b, -mat.a); // Adjust rotation quadrant if needed
      }

      // Extract Rotation (Radians)
      var rotX = Math.atan2(mat.b, mat.a);
      var rotY = Math.atan2(mat.d, mat.c);

      // Convert to Degrees and Normalize for Spine (CCW)
      // Animate is CW, so we negate.
      var rotation = -rotX * (180 / Math.PI);

      // Shear calculation (Difference from 90 degrees)
      // In strict affine math: Shear is the deviation of the Y axis from orthogonality
      var shear = (rotY - rotX - (Math.PI / 2)) * (180 / Math.PI);

      return {
          rotation: rotation,
          scaleX: scaleX,
          scaleY: scaleY,
          shearX: 0, // Spine separates shear, usually map skew to Y
          shearY: -shear // Negate shear to match CCW logic
      };
  }

/\*\*

- Calculates Region Attachment offset to compensate for Custom Pivot.
- @param {Object} element - The JSFL Element
- @param {Object} boneTransform - Result from decomposeMatrix
- @param {Object} transPoint - Point from element.getTransformationPoint()
  \*/
  function getAttachmentOffset(element, boneTransform, transPoint) {
  // 1. Vector from New Pivot (TransPoint) to Old Origin (RegPoint)
  // Note: element.x/y IS the registration point in parent space
  var dx = element.x - transPoint.x;
  var dy = element.y - transPoint.y;
      // 2. Inverse Rotation (Degrees to Radians)
      // We rotate the vector by the NEGATIVE of the bone's rotation to align with local axes
      // Note: The bone rotation is already negated for Spine.
      // We need the inverse of the Spine rotation, which is... positive relative to Spine?
      // Let's stick to the visual logic: We rotate the vector opposite to the bone.
      var r = -boneTransform.rotation * (Math.PI / 180);
      var cos = Math.cos(r);
      var sin = Math.sin(r);

      var rx = dx * cos - dy * sin;
      var ry = dx * sin + dy * cos;

      // 3. Inverse Scale
      return {
          x: rx / boneTransform.scaleX,
          y: ry / boneTransform.scaleY,
          rotation: 0 // Image is typically aligned with bone axes
      };
  }

7. Implications for Inverse Kinematics (IK)The decision to map the Transformation Point to the Bone Origin is not merely a visual fix; it is crucial for the functionality of Inverse Kinematics in Spine. IK solvers rely on the bone length and the pivot location to calculate joint angles. In Animate, the Transformation Point usually corresponds to the anatomical joint (e.g., elbow). If the export script were to default to the Registration Point (often the center of the drawing), the IK solver in Spine would bend the arm at the center of the biceps rather than the elbow.19Therefore, the "Smart Pivot" approach derived in this report—shifting the bone to the transformationPoint and compensating via attachment offsets—is the only method that produces a valid, riggable skeleton for game runtimes.8. ConclusionThe misalignment of assets during Adobe Animate to Spine conversion is a deterministic consequence of conflicting coordinate pivot definitions. Adobe Animate permits a dichotomy between the coordinate origin (Registration Point) and the rotational pivot (Transformation Point), whereas Spine unifies them.The correct mathematical approach involves a change of basis where the Spine bone is instantiated at the global coordinates of the Animate Transformation Point. The disparity between this new origin and the asset's original anchor (the Registration Point) must be calculated as a vector in world space, inversely transformed by the bone’s rotation and scale, and applied as a local translation to the Region Attachment.Implementation of the matrix decomposition logic detailed in Section 4, specifically the extraction of scale/rotation/shear from the $a,b,c,d$ components and the inverse projection of the pivot offset vector, will resolve the reported artifacts. This ensures that the visual fidelity of the Animate timeline is preserved while adhering to the rigorous skeletal hierarchy required by the Spine 4.2 runtime.

Technical Analysis and Migration Protocol: Adobe Animate to Spine 4.2 Interpolation Synthesis1. Introduction to Heterogeneous Animation PipelinesThe transition of animation assets from legacy authoring environments to modern, runtime-optimized skeletal animation systems represents a critical juncture in contemporary game development pipelines. Specifically, the migration from Adobe Animate (formerly Flash Professional) to Esoteric Software’s Spine 4.2 involves navigating a complex impedance mismatch between two fundamentally distinct animation philosophies: the frame-centric, timeline-based model of the early web era and the bone-centric, graph-based continuous interpolation model of modern 2D kinematics.This research report provides an exhaustive technical specification for the development of a JSFL (JavaScript Flash) export script designed to bridge this gap. The primary objective is the accurate translation of animation curves, splines, and easing functions—data structures that define the "feel" and timing of motion. The fidelity of this translation dictates whether the exported assets retain the animator's artistic intent or degrade into mechanical, linear approximations.1.1 The Divergence of Animation ArchitecturesTo understand the complexity of the conversion, one must first analyze the divergent architectures of the two systems. Adobe Animate operates on a paradigm rooted in the metaphor of a physical filmstrip. Time is quantized into discrete frames, and "tweening" (in-betweening) is a calculated state generated between two keyframes. The interpolation logic—whether standard easing or custom curves—is attached to the span of frames itself.In contrast, Spine 4.2 utilizes a continuous time graph where keyframes are merely control points on a function curve $f(t)$. The interpolation is defined by the tangents (handles) of these keys, creating a piecewise cubic Bezier spline that describes the value of a property over infinite time resolution. This distinction is non-trivial; moving from a frame-integer domain to a floating-point time domain requires careful handling of sub-frame sampling and curve approximation.1.2 Scope of AnalysisThe following sections will deconstruct the internal data models of Adobe Animate, specifically focusing on the Frame object and its properties regarding easing and motion guides. We will mathematically derive the necessary formulas to convert Animate’s quadratic easing strengths into Spine’s cubic Bezier control points. Furthermore, we will examine the Spine 4.2 JSON export format, dissecting the changes introduced in Spine 4.0 regarding absolute vs. relative curve representation, and provide a robust algorithmic strategy for matrix decomposition to map Animate’s affine transformations to Spine’s Local SRT (Scale, Rotate, Translate) + Shear model.2. Adobe Animate Internals: The JSFL DOM and Timeline ModelThe JavaScript Flash (JSFL) API provides the necessary hooks to introspect the Document Object Model (DOM) of an Animate file (.fla). However, the API reflects the software's long evolutionary history, containing deprecated properties, overlapping functionality (Classic vs. Motion Tweens), and specific behaviors that must be accounted for during export.2.1 The Timeline and Frame ArchitectureIn Adobe Animate, the hierarchy of data begins with the Timeline object, which contains Layer objects, which in turn contain Frame objects. This structure is rigid; a Frame is not just a point in time but a container for state duration.2.1.1 Frame Object PropertiesThe Frame object is the atomic unit of the export logic. A script must iterate through these frames to reconstruct the flow of animation.frame.startFrame: The integer index where a keyframe begins.frame.duration: The number of frames this state persists or interpolates.frame.tweenType: This property acts as the primary switch statement for the export logic. It takes three distinct string values 3:"motion": Represents the "Motion Tween" (Object-based tween) introduced in Flash CS4. This tween type is characterized by a single object instance spanning multiple frames with properties controlled by a motion path and separate property curves."classic": Represents the "Classic Tween," the legacy method where interpolation is defined between two keyframes. This is the most common format for game assets due to its predictability."none": Represents no interpolation. In the context of Spine, this maps directly to a "Stepped" curve.4Insight: A common error in export scripts is assuming that tweenType accounts for all visual interpolation. "Shape Tweens" are a separate category (frame.tweenType == "shape") 5, but these are generally incompatible with skeletal animation (Spine) unless baked into frame-by-frame mesh attachments, which is outside the scope of curve conversion.2.2 The Classic Tween Interpolation ModelClassic tweens in Animate use a "property-linking" model where multiple properties (Position, Scale, Rotation) share the same timeline span and often the same ease curve, although "Custom Ease" allows for independent property curves.2.2.1 Standard Easing (frame.tweenEasing)The standard ease in Animate is defined by a single scalar value, accessed via frame.tweenEasing. This integer ranges from -100 to 100.6Range Definition:-100 (Ease In): The animation starts at zero velocity and accelerates. The rate of change increases over time.0 (Linear): The rate of change is constant ($v = c$).100 (Ease Out): The animation starts at maximum velocity and decelerates to zero.Mathematically, this slider controls the curvature of a Quadratic Bezier curve. This is a critical distinction from Spine, which uses Cubic Bezier curves. A Quadratic Bezier is defined by three points: a start anchor ($P_0$), a single control point ($P_1$), and an end anchor ($P_2$).Linear: $P_1$ lies exactly on the line segment connecting $P_0$ and $P_2$.Ease In (-100): $P_1$ is pulled towards the time-start ($t=0$) but value-start ($v=0$) corner of the graph.Ease Out (100): $P_1$ is pulled towards the time-start ($t=0$) but value-end ($v=1$) corner, creating an initial steep slope.The "Ease Strength" essentially interpolates the position of this single control point along a defined locus. Recovering the exact coordinates of this control point based on the integer -100 to 100 is a prerequisite for converting the curve to Spine.2.2.2 Custom Easing (frame.getCustomEase())When an animator requires more complex motion than a simple acceleration or deceleration, they utilize the "Custom Ease" dialog. This allows for the creation of curves with multiple inflection points (e.g., an S-curve that eases in and out).Data extraction for this mode is handled via the frame.getCustomEase() method.3Return Structure: This method returns an array of JavaScript objects, each containing x and y properties.[{x: 0, y: 0}, {x: 0.3, y: 0.1}, {x: 0.7, y: 0.9}, {x: 1, y: 1}]Data Interpretation: These points represent the normalized control points of one or more Cubic Bezier segments. The x value represents normalized time (0.0 to 1.0 within the span), and y represents normalized value change (0.0 to 1.0 represents $StartValue$ to $EndValue$).Critical API Behavior: Research indicates that in Animate CC 2019 and later, the getCustomEase() function exhibits a conditional behavior that can cause script failures. If the custom ease intensity is effectively 0 (linear), the method may return undefined rather than an array representing a linear curve.7 The export script must implement a null-check guard: if the return value is null, assume a Linear curve (Spine curve: undefined or curve: "linear").2.3 Motion Tweens and the Motion EditorThe "Motion Tween" (as opposed to Classic) stores data differently. Instead of properties residing on keyframes, the Frame object for a Motion Tween acts as a view into a separate Animation object definition.Property Curves: Motion Tweens allow independent curves for X, Y, Z, Rotation, etc. These are visualized in the Motion Editor.JSFL Access: Accessing the raw curve data for Motion Tweens is notoriously difficult via standard Frame properties. The properties frame.hasCustomEase or frame.tweenEasing are often relics of the Classic model. For Motion Tweens, the easing is often encapsulated in an XML structure accessible via frame.getMotionObjectXML().8Implication: Parsing the internal XML of a Motion Object is computationally expensive and complex. For the purpose of a robust exporter, identifying tweenType == "motion" is often a signal to perform frame-baking (sampling the object's matrix at every frame) rather than attempting to analytically convert the proprietary XML curve definitions to Bezier arrays.3. Mathematical Theory of Interpolation and Coordinate SpacesTo successfully translate animation data, one must bridge the mathematical divide between the two systems. This involves two primary domains: Linear Algebra (for spatial transformations) and Numerical Analysis (for curve conversion).3.1 Affine Transformations and Matrix DecompositionAdobe Animate stores the spatial state of any object as a 2D Affine Transformation Matrix. This matrix encodes translation, scale, rotation, and skew into a 3x3 structure (effectively 6 values for 2D).$$M_{flash} = \begin{bmatrix} a & b & t_x \\ c & d & t_y \\ 0 & 0 & 1 \end{bmatrix}$$$t_x, t_y$: Translation along X and Y.$a, d$: Scaling (and cosine of rotation).$b, c$: Skewing (and sine of rotation).Spine, however, does not store a matrix. It stores specific transform components: Rotation, Translation ($x, y$), Scale ($x, y$), and Shear ($x, y$). To export a keyframe, the script must decompose the Flash matrix into these components.103.1.1 The Decomposition AlgorithmDirect extraction of properties (e.g., element.rotation) is possible in JSFL, but element.matrix is the source of truth, especially for tweened intermediates. The standard QR-decomposition or Polar Decomposition method for 2D matrices is required.12Translation:$$x = M.t_x$$$$y = M.t_y$$Scale and Rotation:Calculating rotation and scale is interdependent due to the possibility of skew (shear).Calculate Scale:$$scaleX = \sqrt{a^2 + b^2}$$$$scaleY = \sqrt{c^2 + d^2}$$Calculate Determinant (Sign):$$det = a \cdot d - b \cdot c$$If $det < 0$, the object is flipped. In Animate, flipping is usually represented by a negative scale. We can flip $scaleY$ (set $scaleY = -scaleY$) to correct the handedness.Calculate Rotation:$$rotation = \arctan2(b, a)$$This returns radians. Convert to degrees: $rotation \cdot (180 / \pi)$.Note: Animate's rotation is clockwise positive. Spine's rotation is counter-clockwise positive. The result must be negated: $rotation_{spine} = -rotation_{flash}$.Calculate Shear (Skew):In a pure rotation/scale matrix, the vectors are orthogonal. If skew exists, they deviate from $90^\circ$.$$shearX = \arctan2(d, c) - \arctan2(b, a) - \frac{\pi}{2}$$(Adjust for quadrant wrapping).Coordinate System Handedness:Animate: Screen space (Y-down).Spine: Cartesian space (Y-up) by default in editor, though runtime implementation varies.13Export Logic: The exporter should typically invert the Y position ($y_{spine} = -y_{flash}$) and invert rotation angles to match the coordinate system change.3.2 Bezier Curve Mathematics: Quadratic to CubicThe central mathematical challenge is converting Animate's Quadratic eases to Spine's Cubic Beziers.3.2.1 Degree ElevationA Bezier curve of degree $n$ can be exactly represented as a Bezier curve of degree $n+1$. This process is called degree elevation.14Quadratic Curve ($Q$): Defined by control points $Q_0, Q_1, Q_2$.Cubic Curve ($C$): Defined by control points $C_0, C_1, C_2, C_3$.To represent $Q$ as $C$:$$C_0 = Q_0 \\ C_1 = Q_0 + \frac{2}{3}(Q_1 - Q_0) \\ C_2 = Q_2 + \frac{2}{3}(Q_1 - Q_2)$$$$C_3 = Q_2$$This formula is the "Rosetta Stone" for the exporter. It allows the script to take the single control point of a Flash ease ($Q_1$) and generate the two control points required by Spine ($C_1, C_2$).3.2.2 NormalizationBoth Animate's ease equations and Spine's JSON format operate on a normalized unit square $ \times $ for the interpolation graph.Time ($t$): 0 is the start frame, 1 is the end frame.Value ($v$): 0 is the start value, 1 is the end value.Therefore, $Q_0 = (0,0)$ and $Q_2 = (1,1)$.The conversion task simplifies to finding the coordinates of $Q_1(x_q, y_q)$ based on the Flash ease strength, and then applying the degree elevation formula to find $C_1$ and $C_2$.4. Easing Mechanics and Conversion LogicThis section details the specific logic for mapping the "Ease Strength" integer to the $Q_1$ coordinates and subsequently to the Spine JSON curve array.4.1 The Standard Ease Equation ($Q_1$ Derivation)Adobe Animate's standard easing equations are derived from Robert Penner's easing functions 15, but the internal slider (-100 to 100) simplifies these into a parameterized quadratic curve.Ease Strength ($S$): An integer from -100 to 100.Normalized Strength ($k$): $k = |S| / 100$.4.1.1 Ease In ($S < 0$)"Ease In" implies the animation starts slowly and accelerates. On a graph of Value ($y$) vs. Time ($x$), the curve is concave up (below the linear diagonal).Target Quadratic shape: $y = x^2$ (Parabola).For $y = x^2$, the quadratic control point $Q_1$ is at $(0.5, 0)$.Proof: A quadratic Bezier with $P_0(0,0), P_1(0.5, 0), P_2(1,1)$ yields $y(t) = t^2$.Interpolation: The Strength $S$ interpolates $Q_1$ from the Linear position $(0.5, 0.5)$ to the Ease In position $(0.5, 0)$.Formula:$$Q_{1x} = 0.5$$$$Q_{1y} = 0.5 \cdot (1 - k)$$4.1.2 Ease Out ($S > 0$)"Ease Out" implies the animation starts fast and decelerates. The curve is concave down (above the linear diagonal).Target Quadratic shape: $y = 1 - (1-x)^2$ (Inverse Parabola).For this shape, the quadratic control point $Q_1$ is at $(0.5, 1)$.Interpolation: The Strength $S$ interpolates $Q_1$ from $(0.5, 0.5)$ to $(0.5, 1)$.Formula:$$Q_{1x} = 0.5$$$$Q_{1y} = 0.5 + 0.5 \cdot k$$4.2 Calculating Spine Control Points ($C_1, C_2$)Once $Q_1(0.5, Q_{1y})$ is derived, we apply the degree elevation formulas derived in Section 3.2.1.Calculate $C_1$ (First Control Point):$$C_{1x} = 0 + \frac{2}{3}(0.5 - 0) = \frac{1}{3} \approx 0.3333$$$$C_{1y} = 0 + \frac{2}{3}(Q_{1y} - 0) = \frac{2}{3} Q_{1y}$$Calculate $C_2$ (Second Control Point):$$C_{2x} = 1 + \frac{2}{3}(0.5 - 1) = 1 - \frac{1}{3} = \frac{2}{3} \approx 0.6667$$$$C_{2y} = 1 + \frac{2}{3}(Q_{1y} - 1)$$The Spine JSON Curve Array:The final output for the curve attribute in Spine is [cx1, cy1, cx2, cy2].Substituting the values:$$curve = [0.3333, \frac{2}{3}Q_{1y}, 0.6667, 1 + \frac{2}{3}(Q_{1y} - 1)]$$This formula provides a mathematically precise translation of Animate's standard ease slider to Spine's cubic Bezier format.4.3 Handling Custom Eases (Piecewise Curves)When frame.hasCustomEase is true, the frame.getCustomEase() method returns an array of point objects. The length of this array determines the strategy.4.3.1 Simple Cubic Curves (4 Points)If the array length is exactly 4, it defines a single Cubic Bezier segment: [P0, C1, C2, P3].Animate stores these as absolute normalized points (0 to 1).Spine expects the control points $C_1$ and $C_2$.Action: Simply extract $point[1]$ and $point[2]$.$cx1 = point.[1]x$$cy1 = point.[1]y$$cx2 = point.[2]x$$cy2 = point.[2]y$4.3.2 Complex Curves (> 4 Points)If the array has more than 4 points, the curve is a Piecewise Bezier Spline (multiple connected curves). For example, a "Bounce" ease might look like a series of arches.Constraint: Spine 4.2 allows only one Bezier curve definition between two keyframes. It does not support multi-segment splines within a single keyframe interval.16Solution: Baking (Sampling).The only way to reproduce a multi-segment custom ease in Spine is to break the Animate span into multiple Spine keyframes.Sampling Rate: Ideally, sample every frame of the Animate span.Calculation: For each frame $f$ in the span, calculate the effective property value. This can be done by temporarily moving the playhead in JSFL (timeline.currentFrame = f) and reading the element's matrix properties.Generation: Create a Spine keyframe for each sampled frame.Interpolation: Set the curve type of these baked keys to "linear" to ensure the sampled path is followed exactly. While this increases the data size (creating a "heavy" animation), it is the only method to guarantee 100% visual fidelity for complex custom eases.5. Advanced Motion: Guides and Spatial SplinesThe "Motion Guide" feature in Animate allows objects to follow a vector path drawn on a guide layer. This presents a unique challenge because it decouples the spatial position ($x, y$) from the property curves. The position is determined by the percentage of path completion.5.1 Geometry Extraction vs. BakingApproach A: Geometry Reconstruction (Path Constraint)Ideally, one would convert the Animate Guide Layer into a Spine Path Attachment.Extraction: Parse the Edge objects on the Guide Layer. Each edge is a cubic Bezier segment.Concatenation: Join edges to form a continuous Spine Path.Constraint: Create a Path Constraint in Spine, bind the bone to it, and animate the position percent.Issues:Tangent discrepancies: Animate's "Orient to Path" algorithm may differ from Spine's tangent calculation, specifically regarding how rotation is blended with the path's normal vector.Open vs. Closed: Handling closed loops vs. open paths requires complex logic to match Animate's specific behavior.Implementation Overhead: Writing a robust SVG-to-Spine-Path parser in JSFL is a massive undertaking prone to edge-case failures.Approach B: Frame Baking (Recommended)Given the high risk of visual discrepancy with Path Constraints, baking is the industry-standard recommendation for export scripts.18Iterate: Loop through every frame of the guided span.Sample: At each frame, the object is visually positioned by Animate along the guide path. Read the element.matrix or element.x/y properties.Write: Output a keyframe with $x, y$ and $rotation$ values.Optimize: A post-process simplification pass can remove redundant keys (where the path is linear) to reduce JSON size, but strictly, linear segments on a curved path will cause "cutting corners." High-density keying is preferred for curves.Conclusion: The script should detect if a layer is Guided (layer.parentLayer.layerType == "guide"). If true, it should automatically switch to a baking routine for that span, generating a dense sequence of keys rather than attempting to define a curve.6. Spine 4.2 Serialization SpecificationsThe final output of the script is a JSON file conforming to the Spine 4.2 schema. A thorough understanding of how Spine version 4.0+ handles curves is essential.6.1 The Absolute vs. Relative Graph ShiftIn Spine 3.8 and earlier, the Graph Editor displayed curves using relative values (time and value differences). In Spine 4.0+, the Graph Editor was rewritten to display absolute values (actual frame numbers and property values) to improve usability.20Implication for JSON:There is a potential confusion regarding whether the JSON export also shifted to absolute coordinates for Bezier handles.Editor: Handles are manipulated in absolute coordinates ($Frame, Value$).JSON Export: Research confirms that for standard curve definitions, the JSON retains the normalized 4-element array [cx1, cy1, cx2, cy2].16cx: Time percentage (0.0 to 1.0).cy: Value percentage (0.0 to 1.0).Why Normalization Persists: Normalization allows the curve definition to be independent of the specific time/value delta. A "Linear" curve is always `` (effectively) regardless of whether the span is 5 frames or 50 frames. This allows runtimes to interpolate efficiently.Edge Case: Zero Value Difference ($\Delta V = 0$):If a bone moves from $x=100$ to $x=100$ over 10 frames (a hold), but has a Bezier curve (e.g., an overshoot), the value-normalized graph (0 to 1) cannot represent the overshoot because the denominator ($\Delta V$) is zero.Spine 4.0+ Handling: In these specific cases, Spine may export a more verbose curve definition or assume a specific behavior.Exporter Strategy: For Animate exports, $\Delta V = 0$ implies no change. If startValue == endValue, the exporter should force the curve type to stepped or linear to avoid division-by-zero errors in the normalization math. Overshoot curves in Animate are rare in standard transforms without explicit keyframing.6.2 Data Mapping TableThe following table summarizes the mapping logic from Animate JSFL properties to Spine JSON attributes.FeatureAdobe Animate (JSFL)Spine 4.2 JSONConversion LogicAnimation Modeframe.tweenType == "none"curve: "stepped"Direct mapping.Animation Modeframe.tweenType == "classic"curve: [cx1, cy1, cx2, cy2]Bezier Degree Elevation (Section 4.2).Easingframe.tweenEasing (-100 to 100)Bezier Control Points$k=Custom Easeframe.getCustomEase()curve: [...] or Baked KeysIf 4 points: Normalize & Export. If >4: Bake.Motion GuideLayer Type "Guide"Keyframes (Linear)Bake frame-by-frame $x, y, rot$.Rotationelement.rotation (Clockwise)rotate (Counter-CW)spineRot = -flashRot. Handle 360 wrapping.Positionelement.x, element.y (Top-Left)x, y (Cartesian)spineY = -flashY.Scaleelement.scaleX, element.scaleYscaleX, scaleYDirect mapping. Detect negative scale for flips.7. Implementation Specification7.1 Script ArchitectureThe JSFL script should be structured into distinct phases to manage complexity and performance.DOM Traversal & Hierarchy Extraction:Walk the timeline.layers.Identify symbols and build a virtual skeleton. Note that Animate does not enforce a strict bone hierarchy; parent-child relationships are often implicit or defined via Layer Parenting (Animate 2019+). The script must resolve this parenting to calculate local transforms for Spine (which requires relative data).Animation Sampling:Iterate through frames.Identify Keyframes ($K_1, K_2$).Extract properties at $K_1$ and $K_2$.Calculate the $\Delta$ (duration and value change).Curve Synthesis:Apply the convertEaseToCubic function to generate curve arrays.Detect "Bake Triggers" (Motion Guides, Complex Custom Eases).If baking is triggered, enter a sub-loop to generate intermediate linear keys.JSON Serialization:Construct the JSON object string.Write to file using FLfile.write().7.2 Code Example: Matrix DecompositionJavaScript/\*\*

- Decomposes a standard 2D affine matrix into Spine-compatible components.
- Accounts for coordinate system differences.
- @param {Object} mat - The JSFL Matrix object {a, b, c, d, tx, ty}
- @returns {Object} - {x, y, rotation, scaleX, scaleY, shearX}
  \*/
  function decomposeMatrix(mat) {
  var a = mat.a;
  var b = mat.b;
  var c = mat.c;
  var d = mat.d;

      // Translation
      var x = mat.tx;
      var y = -mat.ty; // Invert Y for Spine

      // Scale
      // scaleX is magnitude of the first column vector
      var scaleX = Math.sqrt(a * a + b * b);
      // scaleY is magnitude of the second column vector
      var scaleY = Math.sqrt(c * c + d * d);

      // Determinant to check for flipping (negative scale)
      var det = a * d - b * c;
      if (det < 0) {
          scaleY = -scaleY;
      }

      // Rotation (in Radians)
      // In Flash (Y-down), rotation is atan2(b, a).
      // In Spine (Y-up), we generally negate the angle.
      var rotationRad = Math.atan2(b, a);
      var rotation = -(rotationRad * 180 / Math.PI); // Convert to degrees and invert

      // Shear
      // Shear is the deviation from orthogonality.
      // In a pure rotation matrix, the dot product of col1 and col2 is 0.
      // Spine shearX is the angle between Y axis and the X axis normal.
      // Simplified: shear = atan2(d, c) - atan2(b, a) - PI/2
      var rotationYRad = Math.atan2(d, c);
      var shearXRad = rotationYRad - rotationRad - (Math.PI / 2);
      var shearX = -(shearXRad * 180 / Math.PI); // Convert and invert

      return {
          x: x,
          y: y,
          rotation: rotation,
          scaleX: scaleX,
          scaleY: scaleY,
          shearX: shearX
      };

  }

8. ConclusionConverting Adobe Animate projects to Spine 4.2 is a procedure that demands rigorous attention to mathematical detail. The primary obstacle—translating quadratic eases to cubic Beziers—is solvable via degree elevation formulas ($C_1 = Q_0 + \frac{2}{3}(Q_1 - Q_0)$). However, the disparate handling of motion paths and complex curves necessitates a hybrid approach where simple interpolations are analytically converted, and complex motions (Guides, Custom Eases) are baked into frame-by-frame keyframes. By adhering to the coordinate transformations and curve specifications outlined in this report, a developer can construct a reliable pipeline that preserves the visual integrity of legacy Flash animations within the modern Spine runtime environment.
